# 代码阅读指南 - 从零开始理解项目

## 阅读顺序建议

按照以下顺序阅读代码，可以更好地理解整个系统：

1. **README.md** - 了解项目整体概况
2. **platformio.ini** - 了解项目配置和依赖
3. **main.cpp** - 理解主程序流程
4. **SensorManager** - 理解数据采集
5. **FFTProcessor** - 理解频率分析
6. **SymptomDetector** - 理解检测算法
7. **BLEManager** - 理解数据传输

---

## 第一步：理解项目配置 (platformio.ini)

### 文件位置
```
platformio.ini
```

### 关键内容

```ini
[env:disco_l475vg_iot01a]  # STM32硬件环境
platform = ststm32          # STM32平台
board = disco_l475vg_iot01a # 开发板型号
framework = mbed            # 使用Mbed框架

[env:native]                # 电脑测试环境
platform = native           # 原生平台（电脑）
```

### 理解要点
- **两个环境**: 一个用于硬件，一个用于电脑测试
- **Mbed框架**: 提供了硬件抽象层，简化开发
- **构建标志**: 定义了采样频率、窗口大小等关键参数

---

## 第二步：理解主程序流程 (main.cpp)

### 文件位置
```
src/main.cpp
```

### 程序执行流程

#### 1. 初始化阶段（第23-40行）

```cpp
int main() {
    // 1. 初始化传感器（读取硬件或模拟数据）
    sensorManager.begin();
    
    // 2. 初始化症状检测器（准备算法）
    symptomDetector.begin();
    
    // 3. 初始化BLE（准备无线通信）
    bleManager.begin();
}
```

**理解要点**:
- 三个主要组件：传感器、检测器、BLE
- 每个组件都有独立的初始化过程

#### 2. 数据采集循环（第46-107行）

```cpp
while (true) {
    // 检查是否到了采样时间（52Hz = 每19.23ms一次）
    if (currentTime - lastSampleTime >= SAMPLE_INTERVAL_MS) {
        // 读取传感器数据
        SensorData data = sensorManager.read();
        
        // 存储到缓冲区
        accelX[sampleIndex] = data.accelX;
        // ... 存储所有6个轴的数据
        
        sampleIndex++;
        
        // 当收集满156个样本（3秒）时进行分析
        if (sampleIndex >= WINDOW_SIZE) {
            // 进行症状检测
            SymptomResults results = symptomDetector.analyze(...);
            
            // 打印结果
            // 通过BLE发送结果
        }
    }
}
```

**理解要点**:
- **定时采样**: 每19.23ms读取一次数据（52Hz）
- **数据缓冲**: 将数据存储到数组中
- **窗口分析**: 收集满3秒数据后进行分析
- **循环处理**: 分析完一窗口后，继续收集下一窗口

### 关键数据结构

```cpp
// 数据缓冲区：存储3秒的数据（156个样本）
float accelX[156];  // X轴加速度
float accelY[156];  // Y轴加速度
float accelZ[156];  // Z轴加速度
float gyroX[156];   // X轴角速度
float gyroY[156];   // Y轴角速度
float gyroZ[156];   // Z轴角速度
```

---

## 第三步：理解传感器管理 (SensorManager)

### 文件位置
```
src/SensorManager.h
src/SensorManager.cpp
```

### 核心功能

#### 1. 数据结构（SensorManager.h 第7-10行）

```cpp
struct SensorData {
    float accelX, accelY, accelZ;  // 加速度 (单位: g)
    float gyroX, gyroY, gyroZ;     // 角速度 (单位: deg/s)
};
```

**理解要点**:
- 一次读取包含6个值（3轴加速度 + 3轴角速度）
- 单位：g（重力加速度）和 deg/s（度每秒）

#### 2. 初始化（SensorManager.cpp 第24-38行）

```cpp
bool SensorManager::begin() {
    #ifdef MBED_OS
        // 硬件模式：初始化I2C和LSM6DSL传感器
        initHardware();
    #else
        // 模拟模式：用于电脑测试
        simulationMode = true;
    #endif
}
```

**理解要点**:
- **条件编译**: 根据平台选择硬件或模拟模式
- **硬件初始化**: 配置I2C接口，初始化传感器寄存器
- **模拟模式**: 生成测试数据，无需硬件

#### 3. 数据读取（SensorManager.cpp 第55-107行）

```cpp
SensorData SensorManager::read() {
    if (simulationMode) {
        // 生成模拟数据（用于测试）
    } else {
        // 从硬件传感器读取真实数据
        lsm6dsl->readAccel(...);
        lsm6dsl->readGyro(...);
    }
}
```

**理解要点**:
- 统一的接口：无论硬件还是模拟，都返回相同格式的数据
- 硬件读取：通过I2C读取LSM6DSL寄存器
- 模拟数据：生成带噪声的测试信号

---

## 第四步：理解FFT频率分析 (FFTProcessor)

### 文件位置
```
src/FFTProcessor.h
src/FFTProcessor.cpp
```

### 核心概念

#### 什么是FFT？
- **FFT (Fast Fourier Transform)**: 快速傅里叶变换
- **作用**: 将时域信号转换为频域信号
- **输入**: 时间序列数据（如加速度随时间变化）
- **输出**: 频率分布（哪些频率的能量高）

#### 为什么需要FFT？
- 震颤在3-5Hz频率范围内
- 运动障碍在5-7Hz频率范围内
- 需要知道信号中哪些频率的能量高

#### 使用流程（FFTProcessor.h）

```cpp
FFTProcessor fft;
fft.process(data, size, 52.0f);  // 对数据进行FFT

// 获取特定频率的幅值
float magnitude = fft.getMagnitude(bin);
float frequency = fft.getFrequency(bin, 52.0f, size);
```

**理解要点**:
- `process()`: 执行FFT变换
- `getFrequency()`: 获取某个bin对应的频率
- `getMagnitude()`: 获取某个频率的能量大小

---

## 第五步：理解症状检测算法 (SymptomDetector)

### 文件位置
```
src/SymptomDetector.h
src/SymptomDetector.cpp
```

### 检测流程（SymptomDetector.cpp 第15-76行）

#### 1. 数据预处理（第20-39行）

```cpp
// 去均值（去除DC分量）
// 计算平均值
meanX = sum(accelX) / windowSize;

// 减去平均值
processedX[i] = accelX[i] - meanX;
```

**为什么需要去均值？**
- 传感器可能有DC偏移（重力、安装角度等）
- FFT分析需要去除DC分量，只关注交流信号

#### 2. 震颤检测（第49-54行）

```cpp
// 计算3-5Hz频率范围内的能量
results.tremorIntensity = calculateIntensity(..., 3.0f, 5.0f);

// 计算背景噪声（0-2Hz）
backgroundNoise = calculateIntensity(..., 0.0f, 2.0f);

// 判断：强度 > 0.25 且 > 背景噪声的1.2倍
results.tremorDetected = (intensity > 0.25f) && 
                        (intensity > backgroundNoise * 1.2f);
```

**理解要点**:
- 使用FFT计算3-5Hz范围内的能量
- 与背景噪声对比，避免误报
- 阈值：0.25（可调整）

#### 3. 运动障碍检测（第56-60行）

```cpp
// 计算5-7Hz频率范围内的能量
results.dyskinesiaIntensity = calculateIntensity(..., 5.0f, 7.0f);

// 判断逻辑与震颤类似
results.dyskinesiaDetected = (intensity > 0.25f) && 
                            (intensity > backgroundNoise * 1.2f);
```

**理解要点**:
- 检测5-7Hz频率范围
- 使用相同的阈值和背景噪声对比方法

#### 4. 冻结步态检测（第90-120行）

```cpp
// 将数据分成三段
int thirdSize = size / 3;

// 前1/3：行走阶段
float accelVarianceFirst = calculateVariance(前1/3数据);

// 后1/3：可能冻结阶段
float accelVarianceLast = calculateVariance(后1/3数据);

// 判断条件：
// 1. 之前有步态活动（步频 > 0.3步/秒）
// 2. 后段运动很小（方差 < 0.01）
// 3. 突然停止（后段方差 < 前段方差的50%）
bool wasWalking = (cadence > 0.3f);
bool isFrozen = (varianceLast < 0.01f);
bool suddenStop = (varianceLast < varianceFirst * 0.5f);
```

**理解要点**:
- **步态分析**: 先检测是否有行走活动
- **方差分析**: 计算运动的变化程度
- **三段分析**: 比较前段和后段的运动差异
- **冻结判断**: 需要同时满足三个条件

#### 5. 强度计算（calculateIntensity函数）

```cpp
float calculateIntensity(float* data, int size, float minFreq, float maxFreq) {
    // 1. 执行FFT
    FFTProcessor fft;
    fft.process(data, size, 52.0f);
    
    // 2. 在指定频率范围内累加能量
    for (int i = 0; i < size/2; i++) {
        float freq = fft.getFrequency(i, 52.0f, size);
        if (freq >= minFreq && freq <= maxFreq) {
            energy += fft.getMagnitude(i);
        }
    }
    
    // 3. 归一化到0-1范围
    return normalized_energy;
}
```

**理解要点**:
- FFT将数据转换为频域
- 在目标频率范围内累加能量
- 归一化处理，便于比较和设置阈值

---

## 第六步：理解BLE通信 (BLEManager)

### 文件位置
```
src/BLEManager.h
src/BLEManager.cpp
```

### BLE架构

#### 1. BLE服务结构

```
ParkinsonDetector (设备名称)
└── Symptom Detection Service (UUID: 19B10000-...)
    ├── Tremor Characteristic (UUID: 19B10001-...)
    ├── Dyskinesia Characteristic (UUID: 19B10002-...)
    └── FOG Characteristic (UUID: 19B10003-...)
```

**理解要点**:
- **服务 (Service)**: 包含多个特征值的容器
- **特征值 (Characteristic)**: 实际传输数据的单元
- **UUID**: 唯一标识符，用于识别服务和特征值

#### 2. 数据更新流程（BLEManager.cpp 第38-65行）

```cpp
void BLEManager::updateCharacteristics(...) {
    // 1. 将检测结果转换为字节
    tremorStatus = tremorDetected ? 1 : 0;
    tremorIntensityByte = (uint8_t)(tremorIntensity * 255);
    
    // 2. 通过BLE发送数据
    ble->gattServer().write(tremorChar->getValueHandle(), &tremorStatus, 1);
}
```

**理解要点**:
- 将布尔值和浮点数转换为字节
- 通过GATT服务器写入特征值
- 移动设备可以读取或订阅通知

---

## 代码执行流程图

```
启动
  │
  ├─> 初始化传感器 (SensorManager.begin())
  │     ├─> 初始化I2C接口
  │     └─> 配置LSM6DSL传感器（52Hz, ±2g）
  │
  ├─> 初始化检测器 (SymptomDetector.begin())
  │     └─> 重置步态分析变量
  │
  ├─> 初始化BLE (BLEManager.begin())
  │     ├─> 创建BLE服务
  │     ├─> 创建三个特征值
  │     └─> 开始广播
  │
  └─> 进入主循环
        │
        ├─> 每19.23ms (52Hz)
        │     ├─> 读取传感器数据
        │     └─> 存储到缓冲区
        │
        └─> 每3秒 (156个样本)
              ├─> 数据预处理（去均值）
              ├─> FFT频率分析
              ├─> 震颤检测（3-5Hz）
              ├─> 运动障碍检测（5-7Hz）
              ├─> 步态分析
              ├─> 冻结步态检测
              ├─> 打印结果
              └─> 通过BLE发送结果
```

---

## 关键参数说明

### 采样参数
- **采样率**: 52Hz（每秒52个样本）
- **窗口大小**: 156个样本（3秒 × 52Hz）
- **采样间隔**: 19.23ms（1000ms / 52）

### 检测参数
- **震颤频率**: 3-5Hz
- **运动障碍频率**: 5-7Hz
- **震颤阈值**: 强度 > 0.25 且 > 背景噪声 × 1.2
- **运动障碍阈值**: 强度 > 0.25 且 > 背景噪声 × 1.2
- **FOG步频阈值**: > 0.3步/秒
- **FOG方差阈值**: < 0.01

### 传感器配置
- **加速度计量程**: ±2g
- **陀螺仪量程**: ±250dps
- **I2C速度**: 400kHz
- **I2C地址**: 0xD6（自动检测0xD4作为备用）

---

## 调试技巧

### 1. 查看数据流

在 `main.cpp` 中添加调试输出：

```cpp
// 在读取传感器数据后
printf("Accel: X=%.3f, Y=%.3f, Z=%.3f\r\n", 
       data.accelX, data.accelY, data.accelZ);
```

### 2. 查看FFT结果

在 `SymptomDetector.cpp` 中添加：

```cpp
// 在calculateIntensity函数中
printf("Frequency: %.2f Hz, Magnitude: %.2f\r\n", freq, magnitude);
```

### 3. 查看检测过程

在 `SymptomDetector.cpp` 的 `analyze()` 函数中添加：

```cpp
printf("Tremor intensity: %.2f, Background: %.2f\r\n", 
       results.tremorIntensity, backgroundNoise);
```

---

## 常见问题理解

### Q1: 为什么需要3秒窗口？
**A**: 
- FFT需要足够的数据点才能准确分析频率
- 3秒 × 52Hz = 156个样本，满足FFT要求
- 太短：频率分辨率不够
- 太长：检测延迟增加

### Q2: 为什么去均值？
**A**:
- 重力是DC分量（0Hz），会干扰频率分析
- 传感器可能有安装角度，产生DC偏移
- 去除DC后，FFT能更准确地检测交流信号

### Q3: 为什么用背景噪声对比？
**A**:
- 避免误报：正常运动也可能有少量3-5Hz能量
- 提高准确性：只有明显高于背景的信号才认为是症状
- 自适应：不同环境下的噪声水平不同

### Q4: 冻结步态为什么分三段？
**A**:
- 前1/3：正常行走阶段，运动方差大
- 中1/3：过渡阶段
- 后1/3：可能冻结阶段，运动方差小
- 通过对比前后段，可以检测"突然停止"

---

## 下一步学习建议

1. **运行测试程序**: 先看代码运行效果
   ```bash
   pio run -e native -t exec
   ```

2. **单步调试**: 在关键函数处添加printf，观察数据变化

3. **修改参数**: 尝试调整阈值，观察检测效果变化

4. **理解FFT**: 可以搜索"FFT原理"了解数学基础

5. **阅读传感器数据表**: 了解LSM6DSL的寄存器配置

