# 代码阅读指南 - 详细版

## 📚 目录

1. [项目要求理解](#项目要求理解)
2. [代码结构概览](#代码结构概览)
3. [逐步阅读指南](#逐步阅读指南)
4. [关键概念解释](#关键概念解释)
5. [数据流程图](#数据流程图)
6. [调试和理解技巧](#调试和理解技巧)

---

## 项目要求理解

### 核心目标

开发一个**实时症状检测系统**，能够：
1. **采集数据**: 从加速度计和陀螺仪以52Hz采样
2. **分析数据**: 使用FFT分析3秒数据窗口
3. **检测症状**: 识别三种帕金森症状
4. **传输结果**: 通过BLE发送到手机

### 三种症状的医学背景

#### 1. 震颤 (Tremor) - 3-5Hz
- **临床特征**: 手部节律性抖动
- **频率范围**: 3-5Hz（典型4Hz）
- **检测方法**: FFT检测该频率范围内的能量

#### 2. 运动障碍 (Dyskinesia) - 5-7Hz
- **临床特征**: 舞蹈样不自主运动
- **频率范围**: 5-7Hz（典型6Hz）
- **检测方法**: FFT检测该频率范围内的能量
- **重要**: 与震颤频率相邻，需要区分

#### 3. 冻结步态 (FOG) - 非频率特征
- **临床特征**: 行走中突然"卡住"
- **检测方法**: 
  - 步态分析（检测步数和步频）
  - 运动突然停止（方差分析）

---

## 代码结构概览

```
embedded/
├── platformio.ini          # 项目配置（两个环境）
├── src/
│   ├── main.cpp            # 主程序（硬件运行）
│   ├── main_test.cpp       # 测试程序（电脑运行）
│   ├── SensorManager.*     # 传感器管理
│   ├── LSM6DSL.*           # 传感器驱动
│   ├── SymptomDetector.*   # 症状检测算法
│   ├── FFTProcessor.*      # FFT频率分析
│   ├── BLEManager.*        # BLE通信
│   └── mbed_compat.h       # 兼容层
└── test/
    └── main_test.cpp       # 原始测试文件
```

---

## 逐步阅读指南

### 第一步：理解主程序流程 (main.cpp)

#### 文件位置
```
src/main.cpp
```

#### 阅读顺序

**1. 全局变量声明（第20-36行）**

```cpp
// 三个核心对象
SensorManager sensorManager;      // 负责读取传感器
SymptomDetector symptomDetector;  // 负责检测症状
BLEManager bleManager;            // 负责BLE通信

// 数据缓冲区（存储3秒数据）
float accelX[156];  // X轴加速度，156个样本
// ... 其他5个数组
```

**理解要点**:
- 为什么是156？3秒 × 52Hz = 156个样本
- 为什么需要缓冲区？FFT需要完整的数据窗口

**2. 初始化阶段（第49-66行）**

```cpp
int main() {
    // 步骤1: 初始化传感器
    sensorManager.begin();
    // 如果是硬件：初始化I2C和LSM6DSL
    // 如果是模拟：启用模拟模式
    
    // 步骤2: 初始化检测器
    symptomDetector.begin();
    // 重置步态分析变量
    
    // 步骤3: 初始化BLE
    bleManager.begin();
    // 创建BLE服务和特征值，开始广播
}
```

**理解要点**:
- 初始化顺序很重要：先传感器，再检测器，最后BLE
- 每个组件独立初始化，失败不影响其他组件

**3. 主循环（第74-136行）**

这是程序的核心，理解这个循环就理解了整个系统：

```cpp
while (true) {
    // 检查时间：是否到了采样时间？
    if (currentTime - lastSampleTime >= 19.23ms) {
        // 读取传感器数据
        SensorData data = sensorManager.read();
        
        // 存储到缓冲区
        accelX[sampleIndex] = data.accelX;
        // ... 存储所有6个轴
        
        sampleIndex++;
        
        // 检查：缓冲区是否满了？
        if (sampleIndex >= 156) {
            // 缓冲区满了，进行分析
            SymptomResults results = symptomDetector.analyze(...);
            
            // 打印结果
            // 通过BLE发送结果
            
            sampleIndex = 0;  // 重置，开始下一窗口
        }
    }
    
    // 处理BLE事件
    bleManager.update();
}
```

**时间线理解**:
```
时间轴: 0ms -----> 19ms -----> 38ms -----> ... -----> 3000ms
        读取1     读取2        读取3                 读取156
        存储      存储         存储                   分析！
```

---

### 第二步：理解传感器数据采集 (SensorManager)

#### 文件位置
```
src/SensorManager.h
src/SensorManager.cpp
```

#### 关键函数解析

**1. begin() - 初始化（第24-38行）**

```cpp
bool SensorManager::begin() {
    #ifdef MBED_OS
        // 硬件模式
        initHardware();  // 初始化I2C和LSM6DSL
    #else
        // 模拟模式
        simulationMode = true;  // 用于电脑测试
    #endif
}
```

**理解要点**:
- `#ifdef MBED_OS`: 条件编译，根据平台选择代码
- 硬件模式：需要实际传感器
- 模拟模式：生成测试数据

**2. read() - 读取数据（第55-107行）**

```cpp
SensorData SensorManager::read() {
    if (simulationMode) {
        // 生成模拟数据
        // 可以添加不同频率的信号测试算法
    } else {
        // 从硬件读取
        lsm6dsl->readAccel(...);  // 读取加速度
        lsm6dsl->readGyro(...);   // 读取陀螺仪
    }
}
```

**数据单位**:
- 加速度：g（1g = 9.81 m/s²）
- 角速度：deg/s（度每秒）

**3. initHardware() - 硬件初始化（第110-151行）**

```cpp
void SensorManager::initHardware() {
    // 尝试I2C1 (PB7=SDA, PB6=SCL)
    i2c = new I2C(PB_7, PB_6);
    
    // 如果失败，尝试I2C3 (PC1=SDA, PC0=SCL)
    // 自动重试机制
    
    // 创建LSM6DSL驱动
    lsm6dsl = new LSM6DSL(i2c);
    
    // 初始化传感器
    lsm6dsl->init();
}
```

**理解要点**:
- 自动尝试多个I2C配置
- 如果I2C1失败，自动尝试I2C3
- 如果传感器地址0xD6失败，自动尝试0xD4

---

### 第三步：理解FFT频率分析 (FFTProcessor)

#### 文件位置
```
src/FFTProcessor.h
src/FFTProcessor.cpp
```

#### FFT基础概念

**什么是FFT？**

FFT（Fast Fourier Transform）将时域信号转换为频域信号。

**时域 vs 频域**:
```
时域（我们看到的）:
加速度随时间变化: [0.1, 0.2, 0.1, 0.2, ...]

频域（FFT后得到的）:
频率分布: 
- 0Hz: 能量很小
- 4Hz: 能量很大 ← 这就是震颤！
- 6Hz: 能量很大 ← 这就是运动障碍！
```

**使用示例**:

```cpp
// 1. 创建FFT处理器
FFTProcessor fft;

// 2. 处理数据（执行FFT）
float data[156] = {...};  // 3秒的加速度数据
fft.process(data, 156, 52.0f);  // 52Hz采样率

// 3. 查询特定频率的能量
for (int i = 0; i < 78; i++) {  // 78 = 156/2
    float freq = fft.getFrequency(i, 52.0f, 156);
    float magnitude = fft.getMagnitude(i);
    
    if (freq >= 3.0f && freq <= 5.0f) {
        // 这是震颤频率范围！
        tremorEnergy += magnitude;
    }
}
```

**FFT输出理解**:
- **Bin 0**: 0Hz（DC分量）
- **Bin 1**: 52/156 = 0.33Hz
- **Bin 9**: 9×52/156 = 3Hz ← 震颤范围开始
- **Bin 15**: 15×52/156 = 5Hz ← 震颤范围结束
- **Bin 18**: 18×52/156 = 6Hz ← 运动障碍范围

---

### 第四步：理解症状检测算法 (SymptomDetector)

#### 文件位置
```
src/SymptomDetector.h
src/SymptomDetector.cpp
```

#### 检测流程详解

**1. analyze() - 主分析函数（第15-76行）**

这是整个检测系统的核心，让我们逐步理解：

```cpp
SymptomResults analyze(...) {
    // === 步骤1: 数据预处理 ===
    // 去均值（去除DC分量）
    meanX = sum(accelX) / 156;
    processedX[i] = accelX[i] - meanX;
    
    // === 步骤2: 计算加速度幅值 ===
    accelMagnitude[i] = sqrt(X² + Y² + Z²);
    
    // === 步骤3: 震颤检测 ===
    tremorIntensity = calculateIntensity(..., 3.0f, 5.0f);
    backgroundNoise = calculateIntensity(..., 0.0f, 2.0f);
    tremorDetected = (tremorIntensity > 0.25) && 
                    (tremorIntensity > backgroundNoise * 1.2);
    
    // === 步骤4: 运动障碍检测 ===
    // 类似震颤检测，但频率范围是5-7Hz
    
    // === 步骤5: 步态分析 ===
    analyzeGait(...);  // 检测步数，计算步频
    
    // === 步骤6: 冻结步态检测 ===
    fogDetected = detectFOG(...);
}
```

**2. calculateIntensity() - 强度计算（第125-152行）**

这是检测算法的核心：

```cpp
float calculateIntensity(data, size, minFreq, maxFreq) {
    // 1. 执行FFT
    FFTProcessor fft;
    fft.process(data, size, 52.0f);
    
    // 2. 在目标频率范围内累加能量
    for (每个频率bin) {
        if (频率在minFreq和maxFreq之间) {
            energy += fft.getMagnitude(bin);
            maxEnergy = max(maxEnergy, magnitude);
        }
    }
    
    // 3. 组合峰值和平均值
    combinedEnergy = maxEnergy * 0.8 + avgEnergy * 0.2;
    
    // 4. 归一化
    return combinedEnergy / 1.2;
}
```

**为什么这样设计？**
- **峰值能量（80%权重）**: 捕获主导频率成分
- **平均能量（20%权重）**: 捕获整体能量分布
- **归一化**: 便于设置阈值和比较

**3. detectFOG() - 冻结步态检测（第90-122行）**

这是最复杂的检测算法：

```cpp
bool detectFOG(...) {
    // 将3秒数据分成三段
    int thirdSize = 52;  // 每段1秒
    
    // 前1/3：行走阶段
    varianceFirst = calculateVariance(前52个样本);
    
    // 后1/3：可能冻结阶段
    varianceLast = calculateVariance(后52个样本);
    
    // 三个条件必须都满足：
    // 1. 之前有行走（步频 > 0.3步/秒）
    // 2. 现在冻结（方差 < 0.01）
    // 3. 突然停止（后段方差 < 前段方差的50%）
    
    return wasWalking && isFrozen && suddenStop;
}
```

**为什么分三段？**
- 前段：正常行走，运动方差大
- 中段：过渡阶段
- 后段：可能冻结，运动方差小
- 通过对比前后段，可以检测"突然停止"

**4. detectSteps() - 步数检测（第216-250行）**

```cpp
int detectSteps(accelMagnitude, size) {
    // 1. 计算自适应阈值
    threshold = mean + 0.5 * stdDev;
    
    // 2. 检测峰值
    for (每个样本) {
        if (超过阈值 && 是局部最大值) {
            steps++;  // 检测到一个步
        }
    }
    
    return steps;
}
```

**理解要点**:
- 自适应阈值：根据数据自动调整，适应不同运动强度
- 峰值检测：寻找加速度幅值的局部最大值
- 步频计算：steps / 3.0秒

---

### 第五步：理解BLE通信 (BLEManager)

#### 文件位置
```
src/BLEManager.h
src/BLEManager.cpp
```

#### BLE架构理解

**BLE层次结构**:
```
设备 (ParkinsonDetector)
  └── 服务 (Symptom Detection Service)
       ├── 特征值1 (Tremor)
       ├── 特征值2 (Dyskinesia)
       └── 特征值3 (FOG)
```

**初始化流程（第17-96行）**:

```cpp
bool BLEManager::begin() {
    // 1. 初始化BLE栈
    ble->init();
    
    // 2. 设置设备名称
    ble->gap().setDeviceName("ParkinsonDetector");
    
    // 3. 创建特征值
    tremorChar = new GattCharacteristic(...);
    
    // 4. 创建服务（包含所有特征值）
    symptomService = new GattService(..., [tremor, dyskinesia, fog], 3);
    
    // 5. 添加到GATT服务器
    ble->gattServer().addService(*symptomService);
    
    // 6. 开始广播（让手机能发现设备）
    ble->gap().startAdvertising();
}
```

**数据更新流程（第108-162行）**:

```cpp
void updateCharacteristics(...) {
    // 1. 转换数据格式
    tremorStatus = tremorDetected ? 1 : 0;  // bool -> byte
    tremorIntensityByte = intensity * 255;   // float -> byte
    
    // 2. 写入特征值
    ble->gattServer().write(tremorChar, &tremorStatus, 1);
    
    // 3. 触发通知（如果手机订阅了）
    ble->gattServer().handleDataSent();
}
```

---

## 关键概念解释

### 1. 采样率和窗口大小

**为什么52Hz？**
- 项目要求：必须52Hz
- 理论依据：根据Nyquist定理，要检测5Hz信号，采样率至少需要10Hz
- 实际选择：52Hz提供足够的频率分辨率

**为什么3秒窗口？**
- 项目要求：3秒数据窗口
- 计算：3秒 × 52Hz = 156个样本
- 原因：
  - FFT需要足够的数据点
  - 太短：频率分辨率不够
  - 太长：检测延迟增加

### 2. FFT频率分辨率

**频率分辨率计算**:
```
分辨率 = 采样频率 / 样本数
       = 52Hz / 156
       ≈ 0.33Hz
```

**这意味着什么？**
- 每个bin代表约0.33Hz
- 3-5Hz范围：约6个bin（bin 9到bin 15）
- 5-7Hz范围：约6个bin（bin 15到bin 21）

### 3. 去均值（DC移除）

**为什么需要？**
```cpp
// 原始数据可能包含：
accelX = [1.0, 1.1, 1.0, 1.1, ...]  // 包含重力（DC分量）

// 去均值后：
processedX = [0.0, 0.1, 0.0, 0.1, ...]  // 只有交流信号
```

**好处**:
- 去除重力影响
- 去除传感器偏移
- FFT能更准确检测交流信号

### 4. 背景噪声对比

**为什么需要？**
```
正常运动也可能有少量3-5Hz能量
如果只用绝对阈值，会误报

解决方案：与背景噪声对比
- 计算0-2Hz的能量（背景噪声）
- 只有明显高于背景的信号才认为是症状
```

### 5. 方差分析（FOG检测）

**方差是什么？**
```
方差 = 平均值((值 - 均值)²)

高方差 = 数据变化大 = 运动活跃
低方差 = 数据变化小 = 运动静止
```

**FOG检测逻辑**:
```
正常行走：方差大（约0.1-0.5）
冻结状态：方差小（< 0.01）

检测方法：
1. 前段方差大（行走）
2. 后段方差小（冻结）
3. 后段 < 前段的50%（突然停止）
```

---

## 数据流程图

### 完整数据流

```
传感器硬件 (LSM6DSL)
    │
    ├─> I2C通信
    │
    └─> SensorManager::read()
         │
         └─> 返回 SensorData {accelX, accelY, accelZ, gyroX, gyroY, gyroZ}
              │
              └─> main.cpp 存储到缓冲区
                   │
                   └─> 收集156个样本（3秒）
                        │
                        └─> SymptomDetector::analyze()
                             │
                             ├─> 数据预处理（去均值）
                             │
                             ├─> FFT频率分析
                             │   │
                             │   ├─> 震颤检测（3-5Hz）
                             │   ├─> 运动障碍检测（5-7Hz）
                             │   └─> 步态分析
                             │
                             └─> 冻结步态检测（方差分析）
                                  │
                                  └─> 返回 SymptomResults
                                       │
                                       └─> BLEManager::updateCharacteristics()
                                            │
                                            └─> 通过BLE发送到手机
```

### 时间线示例

```
时间轴: 0s -----> 1s -----> 2s -----> 3s -----> 4s
        │        │         │         │         │
        读取     读取      读取       读取      读取
        样本1    样本52    样本104    样本156   样本1（新窗口）
        │        │         │         │         │
        └────────┴─────────┴─────────┘
                 缓冲区满（3秒）
                 │
                 └─> 执行FFT分析
                     │
                     └─> 检测症状
                         │
                         └─> 通过BLE发送结果
```

---

## 调试和理解技巧

### 1. 添加调试输出

**在main.cpp中添加**:
```cpp
// 在读取传感器后
printf("Sample %d: Accel(%.3f, %.3f, %.3f)\r\n", 
       sampleIndex, data.accelX, data.accelY, data.accelZ);
```

**在SymptomDetector.cpp中添加**:
```cpp
// 在calculateIntensity中
printf("Frequency: %.2f Hz, Magnitude: %.2f\r\n", freq, magnitude);
```

### 2. 可视化数据

**理解加速度数据**:
```cpp
// 正常静止：accelZ ≈ 1.0g（重力），accelX/Y ≈ 0
// 震颤：accelX/Y在3-5Hz振荡
// 运动障碍：accelX/Y在5-7Hz振荡
```

### 3. 测试不同场景

**修改测试数据**:
```cpp
// 在SensorManager.cpp的read()函数中
// 可以修改模拟数据来测试不同场景

// 测试震颤：4Hz信号
data.accelX = 0.2 * sin(2π * 4 * time);

// 测试运动障碍：6Hz信号
data.accelX = 0.3 * sin(2π * 6 * time);
```

### 4. 理解FFT输出

**FFT结果解读**:
```
Bin 0:  0.00 Hz (DC分量，已去除)
Bin 9:  3.00 Hz (震颤范围开始)
Bin 12: 4.00 Hz (典型震颤频率)
Bin 15: 5.00 Hz (震颤范围结束，运动障碍开始)
Bin 18: 6.00 Hz (典型运动障碍频率)
Bin 21: 7.00 Hz (运动障碍范围结束)
```

---

## 常见问题解答

### Q1: 为什么需要3秒窗口？不能更短吗？

**A**: 
- FFT需要足够的数据点才能准确分析频率
- 3秒提供0.33Hz的频率分辨率，足够区分3-5Hz和5-7Hz
- 更短：频率分辨率下降，可能无法区分症状
- 更长：检测延迟增加，用户体验差

### Q2: 为什么震颤和运动障碍都用FFT，但FOG不用？

**A**:
- **震颤和运动障碍**: 是频率特征（3-5Hz和5-7Hz），适合FFT
- **FOG**: 是时间特征（突然停止），不适合FFT，用方差分析更合适

### Q3: 为什么需要背景噪声对比？

**A**:
- 正常运动也可能有少量3-5Hz能量
- 只用绝对阈值会误报
- 与背景噪声对比，只有明显高于背景的信号才认为是症状

### Q4: FOG检测为什么分三段？

**A**:
- 需要检测"突然停止"这个特征
- 前段：正常行走（高方差）
- 后段：可能冻结（低方差）
- 对比前后段，可以检测突然变化

### Q5: 步数检测的阈值为什么是 mean + 0.5*stdDev？

**A**:
- 自适应阈值：根据数据自动调整
- mean：平均值
- 0.5*stdDev：半个标准差
- 这样可以在不同运动强度下都能检测到步数

---

## 学习路径建议

### 阶段1：理解整体流程
1. 阅读 `main.cpp`，理解主循环
2. 理解数据采集 → 分析 → 传输的流程

### 阶段2：理解数据采集
1. 阅读 `SensorManager.cpp`
2. 理解硬件读取和模拟模式的区别
3. 理解数据格式和单位

### 阶段3：理解频率分析
1. 学习FFT基础概念（可以搜索"FFT原理"）
2. 阅读 `FFTProcessor.cpp`
3. 理解时域到频域的转换

### 阶段4：理解检测算法
1. 阅读 `SymptomDetector.cpp`
2. 理解每种症状的检测逻辑
3. 尝试修改阈值，观察效果

### 阶段5：理解通信
1. 阅读 `BLEManager.cpp`
2. 理解BLE服务和特征值
3. 了解如何连接手机APP

---

## 实践建议

### 1. 运行测试程序

```bash
pio run -e native -t exec
```

观察输出，理解每个步骤在做什么。

### 2. 修改参数实验

尝试修改 `SymptomDetector.cpp` 中的阈值：
```cpp
// 原来
results.tremorDetected = (intensity > 0.25f) && ...

// 改为
results.tremorDetected = (intensity > 0.15f) && ...
```

观察检测效果如何变化。

### 3. 添加调试信息

在关键函数中添加printf，观察数据变化：
```cpp
printf("Tremor intensity: %.3f, Background: %.3f\r\n", 
       intensity, backgroundNoise);
```

### 4. 理解FFT输出

可以添加代码打印FFT结果：
```cpp
for (int i = 0; i < 30; i++) {
    float freq = fft.getFrequency(i, 52.0f, 156);
    float mag = fft.getMagnitude(i);
    printf("Freq: %.2f Hz, Mag: %.2f\r\n", freq, mag);
}
```

这样可以看到频率分布图。

---

## 总结

### 核心理解点

1. **数据流**: 传感器 → 缓冲区 → FFT分析 → 症状检测 → BLE传输
2. **时间窗口**: 3秒数据窗口，每3秒分析一次
3. **频率分析**: FFT将时域转换为频域，检测特定频率能量
4. **多条件检测**: 每种症状使用不同的检测方法
5. **自适应阈值**: 使用背景噪声对比，减少误报

### 关键文件阅读顺序

1. ✅ `main.cpp` - 理解整体流程
2. ✅ `SensorManager.cpp` - 理解数据采集
3. ✅ `FFTProcessor.cpp` - 理解频率分析
4. ✅ `SymptomDetector.cpp` - 理解检测算法
5. ✅ `BLEManager.cpp` - 理解数据传输

现在你应该能够理解整个系统的工作原理了！

